<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPT Assistant</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            background-color: #ffffff;
            margin: 0;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            min-height: 100vh;
        }

        .chat-container {
            max-width: 1000px;
            margin: 20px auto;
            height: calc(100vh - 40px);
            display: flex;
            flex-direction: column;
            background: #f0f4f8;
            box-shadow: 0 2px 12px rgba(0,0,0,0.08);
            border-radius: 16px;
            position: relative;
            overflow: hidden;
        }

        .chat-header {
            padding: 1rem;
            background: white;
            border-bottom: 1px solid #e4e4e4;
            position: sticky;
            top: 0;
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-header h1 {
            font-size: 1.5rem;
            margin: 0;
            color: #1a1a1a;
        }

        .voice-header-controls {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-left: auto;
        }

        .voice-toggle {
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 6px;
            user-select: none;
        }

        .voice-settings-header-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            width: 32px;
            height: 32px;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .voice-settings-header-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        .help-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .help-content {
            background: white;
            border-radius: 8px;
            padding: 20px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .help-content h3 {
            margin-top: 0;
            color: #333;
        }

        .help-content ul {
            padding-left: 20px;
        }

        .help-content li {
            margin: 8px 0;
        }

        .close-help {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 16px;
            cursor: pointer;
            float: right;
            margin-top: 15px;
        }

        .voice-settings-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1001;
        }

        .voice-settings-content {
            background: white;
            border-radius: 12px;
            padding: 24px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .voice-settings-content h3 {
            margin-top: 0;
            color: #333;
            text-align: center;
        }

        .setting-group {
            margin: 20px 0;
        }

        .setting-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #333;
        }

        .voice-selector {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }

        .tts-mode-group {
            display: flex;
            gap: 10px;
            margin-top: 8px;
        }

        .tts-mode-option {
            flex: 1;
            text-align: center;
        }

        .tts-mode-option input[type="radio"] {
            display: none;
        }

        .tts-mode-option label {
            display: block;
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 13px;
        }

        .tts-mode-option input[type="radio"]:checked + label {
            border-color: #007bff;
            background: #e3f2fd;
            color: #007bff;
        }

        .settings-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 24px;
        }

        .settings-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }

        .settings-btn.primary {
            background: #007bff;
            color: white;
        }

        .settings-btn.secondary {
            background: #6c757d;
            color: white;
        }

        #wave-canvas, #voice-canvas {
            display: none;
            width: 100px;
            height: 20px;
            margin-left: 4px;
        }

        .voice-panel {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 16px;
            padding: 24px;
            margin: 16px 0;
            text-align: center;
            display: none;
            box-shadow: 0 8px 32px rgba(102, 126, 234, 0.3);
            position: relative;
            overflow: hidden;
        }

        .voice-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.05) 100%);
            pointer-events: none;
        }

        .voice-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 24px;
            margin: 20px 0;
            position: relative;
            z-index: 1;
        }

        .voice-mic {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
            color: white;
            border: none;
            border-radius: 50%;
            width: 64px;
            height: 64px;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            box-shadow: 0 4px 16px rgba(255, 107, 107, 0.3);
        }

        .voice-mic:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }

        .voice-mic.recording {
            background: linear-gradient(135deg, #51cf66 0%, #40c057 100%);
            animation: pulse 1.5s infinite;
            box-shadow: 0 4px 16px rgba(81, 207, 102, 0.3);
        }

        @keyframes pulse {
            0% { box-shadow: 0 4px 16px rgba(81, 207, 102, 0.3), 0 0 0 0 rgba(81, 207, 102, 0.7); }
            70% { box-shadow: 0 4px 16px rgba(81, 207, 102, 0.3), 0 0 0 12px rgba(81, 207, 102, 0); }
            100% { box-shadow: 0 4px 16px rgba(81, 207, 102, 0.3), 0 0 0 0 rgba(81, 207, 102, 0); }
        }

        .volume-indicator {
            display: flex;
            align-items: center;
            gap: 12px;
            position: relative;
            z-index: 1;
        }

        .volume-indicator span {
            color: rgba(255, 255, 255, 0.9);
            font-size: 13px;
            font-weight: 500;
        }

        .volume-bars {
            display: flex;
            gap: 3px;
            align-items: flex-end;
            height: 32px;
        }

        .volume-bar {
            width: 4px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 2px;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .voice-status {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            min-height: 60px;
            position: relative;
            z-index: 1;
        }

        .recording-timer {
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
            font-size: 20px;
            font-weight: 600;
            color: #ffffff;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
            background: rgba(255, 255, 255, 0.1);
            padding: 6px 12px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }

        .voice-text {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.9);
            margin-top: 8px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
            font-weight: 500;
        }

        .tts-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            margin-top: 16px;
            position: relative;
            z-index: 1;
        }

        .tts-control-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 8px 16px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            backdrop-filter: blur(10px);
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
        }

        .tts-control-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .message-list {
            flex: 1;
            overflow-y: auto;
            padding: 2rem;
            background: #f8f9fa;
            background-size: auto 100%;
            background-position: center top;
            background-repeat: repeat-x;
            background-attachment: local;
            transition: background-image 0.5s ease;
            position: relative;
            min-height: 500px; /* Ensure sufficient height for background display */
            width: 100%;
        }
        
        /* Background overlay for better readability */
        .message-list::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(248, 249, 250, var(--bg-overlay-opacity, 0.2));
            pointer-events: none;
            z-index: 0;
            transition: background 0.3s ease;
        }
        
        .message-list > * {
            position: relative;
            z-index: 1;
        }

        /* Background CSS Classes */
        .message-list.bg-default {
            background: #f8f9fa !important;
            background-image: none !important;
        }

        .message-list.bg-gradient {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
            background-size: cover !important;
        }

        .message-list.bg-sunset {
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 50%, #fecfef 100%) !important;
            background-size: cover !important;
        }

        .message-list.bg-ocean {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%) !important;
            background-size: cover !important;
        }

        .message-list.bg-forest {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%) !important;
            background-size: cover !important;
        }

        .message-list.bg-anime-beach {
            background-image: url('/static/backgrounds/anime_beach.jpg') !important;
            background-size: auto 100% !important;
            background-position: center top !important;
            background-repeat: repeat-x !important;
            background-attachment: local !important;
        }

        .message-list.bg-anime-starry {
            background-image: url('/static/backgrounds/anime_starry.jpg') !important;
            background-size: auto 100% !important;
            background-position: center top !important;
            background-repeat: repeat-x !important;
            background-attachment: local !important;
        }

        .message-list.bg-anime-sakura {
            background-image: url('/static/backgrounds/anime_sakura.jpg') !important;
            background-size: auto 100% !important;
            background-position: center top !important;
            background-repeat: repeat-x !important;
            background-attachment: local !important;
        }
        
        /* Background Settings Modal */
        .background-settings-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            backdrop-filter: blur(5px);
        }
        
        .background-settings-content {
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            border-radius: 16px;
            padding: 24px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
        }
        
        .background-settings-content h3 {
            margin: 0 0 20px 0;
            color: #333;
            text-align: center;
            font-size: 18px;
        }
        
        .background-section {
            margin-bottom: 24px;
            padding: 16px;
            background: rgba(248, 249, 250, 0.5);
            border-radius: 8px;
            border: 1px solid #e9ecef;
            transition: all 0.3s ease;
        }
        
        .background-section:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        .background-section h4 {
            margin: 0 0 12px 0;
            color: #495057;
            font-size: 14px;
            font-weight: 600;
            text-align: left;
        }
        
        .background-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 12px;
            margin-bottom: 0;
        }
        
        .background-option {
            position: relative;
            aspect-ratio: 16/9;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s ease;
            background-size: cover;
            background-position: center;
        }
        
        .background-option:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
        }
        
        .background-option.selected {
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.3);
        }
        
        .background-option .bg-name {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.7));
            color: white;
            padding: 8px 6px 4px;
            font-size: 11px;
            text-align: center;
            font-weight: 500;
        }
        
        .gradient-bg {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        .gradient-sunset {
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 50%, #fecfef 100%);
        }
        
        .gradient-ocean {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        .gradient-forest {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        }
        
        .custom-upload {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 2px dashed #007bff;
            border-radius: 8px;
            aspect-ratio: 16/9;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #007bff;
            font-size: 12px;
            text-align: center;
            padding: 8px;
        }
        
        .custom-upload:hover {
            background: rgba(0, 123, 255, 0.1);
            transform: scale(1.05);
        }
        
        .opacity-slider {
            margin: 16px 0;
        }
        
        .opacity-slider label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-size: 14px;
            font-weight: 500;
        }
        
        .opacity-slider input[type="range"] {
            width: 100%;
            margin: 4px 0;
        }

        .message {
            display: flex;
            align-items: flex-start;
            margin-bottom: 1.5rem;
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .message.user {
            flex-direction: row-reverse;
        }

        .avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            margin: 0 12px;
            background: #e9ecef;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #495057;
        }

        .user .avatar {
            background: #0d6efd;
            color: white;
        }

        .message-content {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 16px;
            position: relative;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }

        .user .message-content {
            background: #0d6efd;
            color: white;
            border-bottom-right-radius: 4px;
        }

        .assistant .message-content {
            background: white;
            color: #212529;
            border-bottom-left-radius: 4px;
        }

        .input-container {
            padding: 1rem;
            background: white;
            border-top: 1px solid #e4e4e4;
            position: sticky;
            bottom: 0;
        }

        .input-wrapper {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 1000px;
            margin: 0 auto;
        }

        .main-input-row {
            display: flex;
            gap: 10px;
            position: relative;
        }

        .input-with-attachments {
            flex: 1;
            position: relative;
            display: flex;
            flex-direction: column;
        }


        .attachment-preview {
            display: none;
            border: 1px solid #e4e4e4;
            border-radius: 8px;
            padding: 8px;
            margin-bottom: 8px;
            background: #f8f9fa;
            position: relative;
        }

        .attachment-preview.show {
            display: block;
        }

        .preview-image {
            max-width: 150px;
            max-height: 100px;
            border-radius: 4px;
            object-fit: cover;
        }

        .remove-attachment {
            position: absolute;
            top: 4px;
            right: 4px;
            background: rgba(0,0,0,0.6);
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .uploaded-image {
            max-width: 300px;
            max-height: 200px;
            border-radius: 8px;
            margin: 10px 0;
        }

        .image-in-message {
            max-width: 100%;
            border-radius: 8px;
            margin: 10px 0;
        }

        .message-input {
            flex: 1;
            padding: 12px 16px;
            border: 1px solid #e4e4e4;
            border-radius: 24px;
            outline: none;
            transition: border-color 0.2s;
            font-size: 1rem;
        }

        .message-input:focus {
            border-color: #0d6efd;
        }

        .input-area {
            display: flex;
            align-items: center;
            background: white;
            border: 1px solid #e4e4e4;
            border-radius: 24px;
            padding: 0 6px 0 16px;
            transition: border-color 0.2s;
        }

        .input-area:focus-within {
            border-color: #0d6efd;
        }

        .input-area .message-input {
            border: none;
            padding: 12px 8px 12px 0;
        }
        
        .input-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .upload-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            color: #666;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .upload-btn:hover {
            background: #f0f0f0;
            color: #0d6efd;
        }

        .upload-btn svg {
            width: 20px;
            height: 20px;
        }

        #record-btn {
            display: none;
        }

        #record-btn.recording {
            color: #dc3545;
        }

        .send-button {
            padding: 8px 16px;
            background: #0d6efd;
            color: white;
            border: none;
            border-radius: 24px;
            cursor: pointer;
            margin-left: 8px;
            transition: background-color 0.2s;
        }

        .send-button:hover {
            background: #0b5ed7;
        }

        .send-button:disabled {
            background: #e9ecef;
            cursor: not-allowed;
        }

        @media (max-width: 768px) {
            .chat-container {
                height: 100vh;
                margin: 0;
                border-radius: 0;
            }

            .message-content {
                max-width: 85%;
            }
        }

        .cursor {
            display: inline-block;
            width: 2px;
            height: 15px;
            background: currentColor;
            margin-left: 2px;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        /* Voice Settings Modal */
        .voice-settings-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .voice-settings-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 16px;
            padding: 24px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            position: relative;
            overflow: hidden;
        }

        .voice-settings-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.05) 100%);
            pointer-events: none;
        }

        .voice-settings-content > * {
            position: relative;
            z-index: 1;
        }

        .voice-settings-content h3 {
            color: white;
            margin: 0 0 20px 0;
            text-align: center;
            font-size: 20px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .setting-group {
            margin-bottom: 20px;
        }

        .setting-label {
            display: block;
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 8px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        .voice-selector {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 14px;
            backdrop-filter: blur(10px);
        }

        .voice-selector option {
            background: #444;
            color: white;
        }

        .tts-mode-group {
            display: flex;
            gap: 12px;
        }

        .tts-mode-option {
            flex: 1;
            position: relative;
        }

        .tts-mode-option input[type="radio"] {
            position: absolute;
            opacity: 0;
            pointer-events: none;
        }

        .tts-mode-option label {
            display: block;
            padding: 12px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.9);
            font-size: 13px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .tts-mode-option input[type="radio"]:checked + label {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .tts-mode-option label small {
            display: block;
            margin-top: 4px;
            opacity: 0.8;
            font-size: 11px;
        }

        .settings-buttons {
            display: flex;
            gap: 12px;
            margin-top: 24px;
        }

        .settings-btn {
            flex: 1;
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        .settings-btn.primary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .settings-btn.primary:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .settings-btn.secondary {
            background: rgba(0, 0, 0, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .settings-btn.secondary:hover {
            background: rgba(0, 0, 0, 0.3);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        /* Alternative background modes - you can switch between these */
        
        /* Mode 1: Current - Height-fit with horizontal repeat (best for portraits) */
        .bg-mode-portrait {
            background-size: auto 100% !important;
            background-position: center top !important;
            background-repeat: repeat-x !important;
        }
        
        /* Mode 2: Contain - Show full image without cropping */
        .bg-mode-contain {
            background-size: contain !important;
            background-position: center !important;
            background-repeat: no-repeat !important;
        }
        
        /* Mode 3: Cover - Fill entire area (may crop image) */
        .bg-mode-cover {
            background-size: cover !important;
            background-position: center !important;
            background-repeat: no-repeat !important;
        }
        
        /* Mode 4: Fixed aspect ratio */
        .bg-mode-fixed {
            background-size: 100% auto !important;
            background-position: center top !important;
            background-repeat: repeat-y !important;
        }

        /* Specific styles for different background sections */
        .background-section:first-of-type {
            background: linear-gradient(135deg, rgba(255, 193, 7, 0.1) 0%, rgba(255, 235, 59, 0.05) 100%);
            border-color: rgba(255, 193, 7, 0.2);
        }
        
        .background-section:last-of-type {
            background: linear-gradient(135deg, rgba(13, 202, 240, 0.1) 0%, rgba(13, 110, 253, 0.05) 100%);
            border-color: rgba(13, 202, 240, 0.2);
        }
        
        /* Add small theme indicators */
        .background-section h4::before {
            content: '';
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
            vertical-align: middle;
        }
        
        .background-section:first-of-type h4::before {
            background: linear-gradient(135deg, #ffc107, #ff8b00);
        }
        
        .background-section:last-of-type h4::before {
            background: linear-gradient(135deg, #0dcaf0, #0d6efd);
        }
    </style>
</head>
<body>
    <div class="chat-container">
        <div class="chat-header">
            <h1>GPT Assistant</h1>
            <div class="voice-header-controls">
            <label class="voice-toggle form-check form-switch">
                <input class="form-check-input" type="checkbox" id="voice-mode-toggle">
                <span class="form-check-label" for="voice-mode-toggle">Voice Mode</span>
            </label>
                <button id="background-settings-header" class="voice-settings-header-btn" title="Background Settings">üé®</button>
                <button id="voice-settings-header" class="voice-settings-header-btn" title="Voice Settings">‚öôÔ∏è</button>
            </div>
        </div>
        <div class="message-list" id="message-list"></div>
        <div id="voice-panel" class="voice-panel">
            <div class="voice-controls">
                <div class="volume-indicator">
                    <span>Volume:</span>
                    <div class="volume-bars" id="volume-bars">
                        <div class="volume-bar"></div>
                        <div class="volume-bar"></div>
                        <div class="volume-bar"></div>
                        <div class="volume-bar"></div>
                        <div class="volume-bar"></div>
                        <div class="volume-bar"></div>
                        <div class="volume-bar"></div>
                        <div class="volume-bar"></div>
                    </div>
                </div>
                <div class="voice-status">
                    <div id="recording-timer" class="recording-timer">00:00</div>
                    <div id="voice-text" class="voice-text">Click the microphone to start recording</div>
                </div>
            </div>
            <button id="voice-mic" class="voice-mic">üé§</button>
            <canvas id="voice-canvas" style="display: none;"></canvas>
            <div id="tts-controls" class="tts-controls" style="display: none;">
                <button id="tts-stop" class="tts-control-btn">Stop Playback</button>
            </div>
        </div>
        <div class="input-container" id="text-panel">
            <form id="message-form" class="input-wrapper">
                <div class="main-input-row">
                    <div class="input-with-attachments">
                        <div class="attachment-preview" id="attachment-preview">
                            <img class="preview-image" id="preview-image" alt="Preview">
                            <button type="button" class="remove-attachment" id="remove-attachment">√ó</button>
                        </div>
                        <div class="input-area">
                            <input type="text" class="message-input" id="message-input" placeholder="Type a message... (supports text, image understanding & generation)" required>
                            <div class="input-actions">
                                <button type="button" class="upload-btn" id="upload-btn" title="Upload Image">
                                    <svg viewBox="0 0 24 24" fill="currentColor">
                                        <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z" />
                                    </svg>
                                </button>
                                <button type="button" class="upload-btn" id="record-btn" title="Record Voice">
                                    <svg viewBox="0 0 24 24" fill="currentColor">
                                        <path d="M12 14a3 3 0 0 0 3-3V5a3 3 0 0 0-6 0v6a3 3 0 0 0 3 3m5-3a5 5 0 0 1-10 0H5a7 7 0 0 0 14 0h-2m-5 8v3h4v2H8v-2h4v-3h2Z" />
                                    </svg>
                                </button>
                                <canvas id="wave-canvas"></canvas>
                                <input type="file" id="image-input" accept="image/*" style="display: none;">
                                <button type="submit" class="send-button">Send</button>
                            </div>
                        </div>
                    </div>
                </div>
            </form>
        </div>
    </div>

    <script>

document.addEventListener('DOMContentLoaded', function() {
    const messageList = document.getElementById('message-list');
    const messageForm = document.getElementById('message-form');
    const messageInput = document.getElementById('message-input');
    const sendButton = messageForm.querySelector('button');
    const uploadBtn = document.getElementById('upload-btn');
    const imageInput = document.getElementById('image-input');
    const attachmentPreview = document.getElementById('attachment-preview');
    const previewImage = document.getElementById('preview-image');
    const removeAttachmentBtn = document.getElementById('remove-attachment');
    const voiceToggle = document.getElementById('voice-mode-toggle');
    const textPanel = document.getElementById('text-panel');
    const voicePanel = document.getElementById('voice-panel');
    const voiceCanvas = document.getElementById('voice-canvas');
    const voiceMic = document.getElementById('voice-mic');
    const voiceText = document.getElementById('voice-text');
    const recordingTimer = document.getElementById('recording-timer');
    const volumeBars = document.querySelectorAll('.volume-bar');
    const ttsControls = document.getElementById('tts-controls');
    const ttsStopBtn = document.getElementById('tts-stop');
    const voiceSettingsHeaderBtn = document.getElementById('voice-settings-header');
    const backgroundSettingsHeaderBtn = document.getElementById('background-settings-header');

    let uploadedImageUrl = null;
    let voiceMode = false;
    let mediaRecorder = null;
    let audioChunks = [];
    let vadStream = null;
    let audioCtx = null;
    let analyser = null;
    let vadInterval = null;
    let recording = false;
    let silenceFrames = 0;
    let recordingStartTime = 0;
    let recordingTimerInterval = null;
    let currentAudio = null;
    let selectedVoice = 'alloy';
            let ttsMode = 'complete'; // 'complete' or 'streaming'
    let streamingTTSBuffer = '';
    let streamingTTSTimeout = null;
    
    // Background settings
    let currentBackground = 'default';
    let backgroundOpacity = 0.8;
    let customBackgroundUrl = null;

    // Check Voice Mode compatibility
    function checkVoiceModeCompatibility() {
        console.log('üé§ Checking Voice Mode compatibility...');
        
        // Check for any getUserMedia support (modern or legacy)
        const hasModernAPI = navigator.mediaDevices && navigator.mediaDevices.getUserMedia;
        const hasLegacyAPI = navigator.getUserMedia || 
                           navigator.webkitGetUserMedia || 
                           navigator.mozGetUserMedia || 
                           navigator.msGetUserMedia;
        
        if (!hasModernAPI && !hasLegacyAPI) {
            console.warn('‚ùå Browser does not support microphone access');
            console.warn('‚ÑπÔ∏è Please update to a modern browser');
            return false;
        }
        
        if (hasModernAPI) {
            console.log('‚úÖ Modern mediaDevices API supported');
        } else if (hasLegacyAPI) {
            console.log('‚ö†Ô∏è Using legacy getUserMedia API (limited features)');
        }
        
        // HTTPS check is less strict for older browsers
        if (hasModernAPI && location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
            console.warn('‚ö†Ô∏è Voice features work better with HTTPS connection');
            console.warn('‚ÑπÔ∏è Current URL:', location.href);
        }
        
        console.log('‚úÖ Voice Mode compatibility check passed');
        return true;
    }

    // Debug Voice Mode toggle
    const isVoiceModeSupported = checkVoiceModeCompatibility();
    console.log('üé§ Voice Mode toggle element:', voiceToggle);
    console.log('üé§ Voice Mode initial state:', voiceToggle ? voiceToggle.checked : 'Element not found');
    console.log('üé§ Voice Mode supported:', isVoiceModeSupported);

    if (voiceToggle) {
        voiceToggle.addEventListener('change', async () => {
            console.log('üé§ Voice Mode toggle changed:', voiceToggle.checked);
            voiceMode = voiceToggle.checked;
            textPanel.style.display = voiceMode ? 'none' : '';
            voicePanel.style.display = voiceMode ? 'block' : 'none';
            if (voiceMode) {
                try {
                    console.log('üé§ Starting voice mode...');
                    await startVoiceMode();
                    voiceText.textContent = 'Voice mode activated, click microphone to start recording';
                    ttsControls.style.display = 'flex';
                    console.log('üé§ Voice mode started successfully');
                } catch (error) {
                    console.error('Failed to start voice mode:', error);
                    
                    let errorMessage = 'Cannot start voice mode: ';
                    if (error.message.includes('microphone access')) {
                        errorMessage += 'Your browser does not support voice features. Please update your browser.';
                    } else if (error.message.includes('audio recording')) {
                        errorMessage += 'Your browser does not support audio recording. Please update your browser.';
                    } else if (error.message.includes('HTTPS connection')) {
                        errorMessage += 'Voice features require HTTPS (secure connection)';
                    } else if (error.name === 'NotAllowedError') {
                        errorMessage += 'Please allow microphone access';
                    } else if (error.name === 'NotFoundError') {
                        errorMessage += 'No microphone found';
                    } else if (error.name === 'NotReadableError') {
                        errorMessage += 'Microphone is being used by another application';
                    } else if (error.name === 'SecurityError') {
                        errorMessage += 'Security restrictions prevent microphone access';
                    } else {
                        errorMessage += 'Please check microphone permissions';
                    }
                    
                    voiceText.textContent = errorMessage;
                    voiceToggle.checked = false;
                    voiceMode = false;
                    textPanel.style.display = '';
                    voicePanel.style.display = 'none';
                }
            } else {
                console.log('üé§ Stopping voice mode...');
                stopVoiceMode();
            }
        });

        // Also add click event listener for additional debugging
        voiceToggle.addEventListener('click', () => {
            console.log('üé§ Voice Mode toggle clicked');
        });
    } else {
        console.error('‚ùå Voice Mode toggle element not found!');
    }

    // Add TTS control event listeners
    ttsStopBtn.addEventListener('click', () => {
        // Stop current audio
        if (currentAudio) {
            currentAudio.pause();
            currentAudio = null;
        }
        
        // Clear all audio queues
        audioQueue = [];
        isPlayingQueue = false;
        streamingAudioQueue.forEach(url => URL.revokeObjectURL(url));
        streamingAudioQueue = [];
        isPlayingStreamingQueue = false;
        
        ttsStopBtn.textContent = 'Stop Playback';
    });

    voiceSettingsHeaderBtn.addEventListener('click', showVoiceSettings);
    backgroundSettingsHeaderBtn.addEventListener('click', showBackgroundSettings);

    function showVoiceSettings() {
        const modal = document.createElement('div');
        modal.className = 'voice-settings-modal';
        modal.innerHTML = `
            <div class="voice-settings-content">
                <h3>üéôÔ∏è Voice Settings</h3>
                
                <div class="setting-group">
                    <label class="setting-label">TTS Voice Selection</label>
                    <select class="voice-selector" id="voice-selector-modal">
                        <option value="alloy" ${selectedVoice === 'alloy' ? 'selected' : ''}>Alloy - Standard Voice</option>
                        <option value="echo" ${selectedVoice === 'echo' ? 'selected' : ''}>Echo - Echo Effect</option>
                        <option value="fable" ${selectedVoice === 'fable' ? 'selected' : ''}>Fable - Story Voice</option>
                        <option value="onyx" ${selectedVoice === 'onyx' ? 'selected' : ''}>Onyx - Deep Voice</option>
                        <option value="nova" ${selectedVoice === 'nova' ? 'selected' : ''}>Nova - Modern Voice</option>
                        <option value="shimmer" ${selectedVoice === 'shimmer' ? 'selected' : ''}>Shimmer - Bright Voice</option>
                    </select>
                </div>

                <div class="setting-group">
                    <label class="setting-label">TTS Playback Mode</label>
                    <div class="tts-mode-group">
                        <div class="tts-mode-option">
                            <input type="radio" id="tts-complete" name="tts-mode" value="complete" ${ttsMode === 'complete' ? 'checked' : ''}>
                            <label for="tts-complete">Complete Playback<br><small>Play after response is complete</small></label>
                        </div>
                        <div class="tts-mode-option">
                            <input type="radio" id="tts-streaming" name="tts-mode" value="streaming" ${ttsMode === 'streaming' ? 'checked' : ''}>
                            <label for="tts-streaming">Streaming Playback<br><small>Real-time playback (faster)</small></label>
                        </div>
                    </div>
                </div>

                <div class="settings-buttons">
                    <button class="settings-btn secondary" onclick="this.closest('.voice-settings-modal').remove()">Cancel</button>
                    <button class="settings-btn primary" id="save-voice-settings">Save Settings</button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        // Add save button event listener
        modal.querySelector('#save-voice-settings').addEventListener('click', () => {
            const voiceSelector = modal.querySelector('#voice-selector-modal');
            const ttsRadios = modal.querySelectorAll('input[name="tts-mode"]');
            
            selectedVoice = voiceSelector.value;
            
            for (const radio of ttsRadios) {
                if (radio.checked) {
                    ttsMode = radio.value;
                    break;
                }
            }
            
            // Save to localStorage
            localStorage.setItem('voiceSettings', JSON.stringify({
                voice: selectedVoice,
                mode: ttsMode
            }));
            
            console.log(`Voice settings saved: voice=${selectedVoice}, mode=${ttsMode}`);
            modal.remove();
        });
        
        // Click background to close modal
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                modal.remove();
            }
        });
    }

    function showBackgroundSettings() {
        // ‰øùÂ≠òÂΩìÂâçËÆæÁΩÆ‰ª•‰æøÂèñÊ∂àÊó∂ÊÅ¢Â§ç
        const originalBackground = currentBackground;
        const originalOpacity = backgroundOpacity;
        const originalCustomUrl = customBackgroundUrl;
        
        const modal = document.createElement('div');
        modal.className = 'background-settings-modal';
        modal.innerHTML = `
            <div class="background-settings-content">
                <h3>üé® Background Settings</h3>
                <p style="text-align: center; color: #6c757d; font-size: 13px; margin-bottom: 20px;">
                    Choose from color themes or upload your own image background
                </p>
                
                <!-- Color Themes Section -->
                <div class="background-section">
                    <h4>üåà Color Themes</h4>
                    <div class="background-grid">
                        <div class="background-option ${currentBackground === 'default' ? 'selected' : ''}" data-bg="default">
                            <div class="bg-name">üé® Default</div>
                        </div>
                        
                        <div class="background-option gradient-bg ${currentBackground === 'gradient' ? 'selected' : ''}" data-bg="gradient">
                            <div class="bg-name">üé® Gradient</div>
                        </div>
                        
                        <div class="background-option gradient-sunset ${currentBackground === 'sunset' ? 'selected' : ''}" data-bg="sunset">
                            <div class="bg-name">üé® Sunset</div>
                        </div>
                        
                        <div class="background-option gradient-ocean ${currentBackground === 'ocean' ? 'selected' : ''}" data-bg="ocean">
                            <div class="bg-name">üé® Ocean</div>
                        </div>
                        
                        <div class="background-option gradient-forest ${currentBackground === 'forest' ? 'selected' : ''}" data-bg="forest">
                            <div class="bg-name">üé® Forest</div>
                        </div>
                    </div>
                </div>
                
                <!-- Image Backgrounds Section -->
                <div class="background-section">
                    <h4>üñºÔ∏è Image Backgrounds</h4>
                    <div class="background-grid">
                        <div class="background-option ${currentBackground === 'anime_beach' ? 'selected' : ''}" data-bg="anime_beach" 
                             style="background-image: url('/static/backgrounds/anime_beach.jpg'); background-size: cover; background-position: center;">
                            <div class="bg-name">üèñÔ∏è Anime Beach</div>
                        </div>
                        
                        <div class="background-option ${currentBackground === 'anime_starry' ? 'selected' : ''}" data-bg="anime_starry"
                             style="background-image: url('/static/backgrounds/anime_starry.jpg'); background-size: cover; background-position: center;">
                            <div class="bg-name">üåå Starry Night</div>
                        </div>
                        
                        <div class="background-option ${currentBackground === 'anime_sakura' ? 'selected' : ''}" data-bg="anime_sakura"
                             style="background-image: url('/static/backgrounds/anime_sakura.jpg'); background-size: cover; background-position: center;">
                            <div class="bg-name">üå∏ Sakura Forest</div>
                        </div>
                        
                        <div class="custom-upload" id="custom-bg-upload">
                            <div>üìÅ</div>
                            <div>üñºÔ∏è Upload Custom</div>
                            <input type="file" id="bg-file-input" accept="image/*" style="display: none;">
                        </div>
                    </div>
                </div>
                
                <div class="opacity-slider">
                    <label for="bg-opacity">Background Opacity: <span id="opacity-value">${Math.round(backgroundOpacity * 100)}%</span></label>
                    <input type="range" id="bg-opacity" min="0.1" max="1" step="0.1" value="${backgroundOpacity}">
                </div>

                <div class="settings-buttons">
                    <button class="settings-btn secondary" id="cancel-background-settings">Cancel</button>
                    <button class="settings-btn primary" id="save-background-settings">Save Settings</button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        // Background option selection
        modal.querySelectorAll('.background-option').forEach(option => {
            option.addEventListener('click', () => {
                console.log('Background option clicked:', option.dataset.bg);
                modal.querySelectorAll('.background-option').forEach(opt => opt.classList.remove('selected'));
                option.classList.add('selected');
                currentBackground = option.dataset.bg;
                console.log('Current background set to:', currentBackground);
                // Á´ãÂç≥Â∫îÁî®ËÉåÊôØÈ¢ÑËßà
                applyBackground();
            });
        });
        
        // Custom background upload
        const customUpload = modal.querySelector('#custom-bg-upload');
        const fileInput = modal.querySelector('#bg-file-input');
        
        customUpload.addEventListener('click', () => {
            fileInput.click();
        });
        
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file && file.type.startsWith('image/')) {
                const reader = new FileReader();
                                 reader.onload = (e) => {
                     currentBackground = 'custom';
                     customBackgroundUrl = e.target.result;
                     modal.querySelectorAll('.background-option').forEach(opt => opt.classList.remove('selected'));
                     customUpload.style.backgroundImage = `url(${e.target.result})`;
                     customUpload.style.backgroundSize = 'cover';
                     customUpload.style.backgroundPosition = 'center';
                     customUpload.innerHTML = '<div class="bg-name">üñºÔ∏è Custom</div>';
                     customUpload.classList.add('selected');
                     // Á´ãÂç≥Â∫îÁî®Ëá™ÂÆö‰πâËÉåÊôØÈ¢ÑËßà
                     applyBackground();
                 };
                reader.readAsDataURL(file);
            }
        });
        
        // Opacity slider
        const opacitySlider = modal.querySelector('#bg-opacity');
        const opacityValue = modal.querySelector('#opacity-value');
        
        opacitySlider.addEventListener('input', (e) => {
            backgroundOpacity = parseFloat(e.target.value);
            opacityValue.textContent = Math.round(backgroundOpacity * 100) + '%';
            updateBackgroundOpacity();
        });
        
        // Cancel button - restore original settings
        modal.querySelector('#cancel-background-settings').addEventListener('click', () => {
            currentBackground = originalBackground;
            backgroundOpacity = originalOpacity;
            customBackgroundUrl = originalCustomUrl;
            applyBackground();
            modal.remove();
        });
        
        // Save settings
        modal.querySelector('#save-background-settings').addEventListener('click', () => {
            // ËÉåÊôØÂ∑≤ÁªèÂÆûÊó∂Â∫îÁî®‰∫ÜÔºåÂè™ÈúÄË¶Å‰øùÂ≠òËÆæÁΩÆ
            saveBackgroundSettings();
            modal.remove();
        });
        
        // Click background to close modal - restore original settings
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                currentBackground = originalBackground;
                backgroundOpacity = originalOpacity;
                customBackgroundUrl = originalCustomUrl;
                applyBackground();
                modal.remove();
            }
        });
    }

    // Load saved voice settings
    function loadVoiceSettings() {
        try {
            const saved = localStorage.getItem('voiceSettings');
            if (saved) {
                const settings = JSON.parse(saved);
                selectedVoice = settings.voice || 'alloy';
                ttsMode = settings.mode || 'complete';
            }
        } catch (e) {
            console.log('Failed to load voice settings, using defaults');
        }
    }

    // Restore settings on page load
    loadVoiceSettings();
    
    // Background management functions
    function applyBackground() {
        const messageList = document.getElementById('message-list');
        console.log('Applying background:', currentBackground);
        
        // Remove all background classes first
        messageList.classList.remove('bg-default', 'bg-gradient', 'bg-sunset', 'bg-ocean', 'bg-forest', 'bg-anime-beach', 'bg-anime-starry', 'bg-anime-sakura');
        
        // Clear any inline styles
        messageList.style.removeProperty('background');
        messageList.style.removeProperty('background-image');
        
        // Add the appropriate background class
        let className = 'bg-default';
        switch(currentBackground) {
            case 'default':
                className = 'bg-default';
                break;
            case 'gradient':
                className = 'bg-gradient';
                break;
            case 'sunset':
                className = 'bg-sunset';
                break;
            case 'ocean':
                className = 'bg-ocean';
                break;
            case 'forest':
                className = 'bg-forest';
                break;
            case 'anime_beach':
                className = 'bg-anime-beach';
                break;
            case 'anime_starry':
                className = 'bg-anime-starry';
                break;
            case 'anime_sakura':
                className = 'bg-anime-sakura';
                break;
            case 'custom':
                if (customBackgroundUrl) {
                    messageList.style.setProperty('background-image', `url(${customBackgroundUrl})`, 'important');
                    messageList.style.setProperty('background-size', 'auto 100%', 'important');
                    messageList.style.setProperty('background-position', 'center top', 'important');
                    messageList.style.setProperty('background-repeat', 'repeat-x', 'important');
                    messageList.style.setProperty('background-attachment', 'local', 'important');
                    console.log('Applied custom background:', customBackgroundUrl);
                } else {
                    className = 'bg-default';
                    console.log('No custom background URL available, using default');
                }
                break;
            default:
                className = 'bg-default';
        }
        
        if (currentBackground !== 'custom') {
            messageList.classList.add(className);
        }
        
        updateBackgroundOpacity();
        
        // Add debug output
        console.log('‚úÖ Background applied successfully!');
        console.log('  CSS class:', className);
        console.log('  Element classes:', messageList.className);
        console.log('  Overlay opacity:', document.documentElement.style.getPropertyValue('--bg-overlay-opacity'));
    }
    
    function updateBackgroundOpacity() {
        const messageList = document.getElementById('message-list');
        
        if (currentBackground === 'default') {
            // No overlay for default background
            document.documentElement.style.setProperty('--bg-overlay-opacity', '0');
        } else {
            // Apply minimal overlay for better text readability while keeping background visible
            const adjustedOpacity = Math.min(backgroundOpacity * 0.3, 0.2);
            document.documentElement.style.setProperty('--bg-overlay-opacity', adjustedOpacity.toString());
        }
        
        console.log(`Background opacity updated to: ${backgroundOpacity}`);
    }
    
    function saveBackgroundSettings() {
        try {
            const settings = {
                background: currentBackground,
                opacity: backgroundOpacity,
                customUrl: customBackgroundUrl
            };
            localStorage.setItem('backgroundSettings', JSON.stringify(settings));
            console.log('Background settings saved:', settings);
        } catch (e) {
            console.log('Failed to save background settings:', e);
        }
    }
    
    function loadBackgroundSettings() {
        try {
            const saved = localStorage.getItem('backgroundSettings');
            if (saved) {
                const settings = JSON.parse(saved);
                currentBackground = settings.background || 'default';
                backgroundOpacity = settings.opacity || 0.8;
                customBackgroundUrl = settings.customUrl || null;
                applyBackground();
            }
        } catch (e) {
            console.log('Failed to load background settings, using defaults');
        }
    }
    
    // Load background settings on page load
    loadBackgroundSettings();
    
    // Add debugging for background application
    console.log('Background system initialized');
    console.log('Current background:', currentBackground);
    console.log('Current opacity:', backgroundOpacity);
    
    // Test background function for debugging
    window.testBackground = function(bg) {
        console.log('üß™ Testing background:', bg);
        currentBackground = bg;
        applyBackground();
        saveBackgroundSettings();
    };

    // Test Voice Mode toggle function
    window.testVoiceMode = function() {
        console.log('üß™ Testing Voice Mode toggle...');
        if (voiceToggle) {
            console.log('Current state:', voiceToggle.checked);
            voiceToggle.checked = !voiceToggle.checked;
            console.log('New state:', voiceToggle.checked);
            voiceToggle.dispatchEvent(new Event('change'));
        } else {
            console.error('‚ùå Voice toggle element not found');
        }
    };

    // Check Voice Mode status function
    window.checkVoiceMode = function() {
        console.log('üîç Voice Mode Status Check:');
        console.log('  Browser compatibility:', checkVoiceModeCompatibility());
        console.log('  Current protocol:', location.protocol);
        console.log('  Current hostname:', location.hostname);
        console.log('  Toggle element found:', !!voiceToggle);
        console.log('  Current toggle state:', voiceToggle ? voiceToggle.checked : 'N/A');
        console.log('  Voice mode active:', voiceMode);
        
        // Detailed browser capability check
        console.log('');
        console.log('üîß Browser Capabilities:');
        console.log('  navigator.mediaDevices:', !!navigator.mediaDevices);
        console.log('  navigator.mediaDevices.getUserMedia:', !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia));
        console.log('  navigator.getUserMedia:', !!navigator.getUserMedia);
        console.log('  navigator.webkitGetUserMedia:', !!navigator.webkitGetUserMedia);
        console.log('  navigator.mozGetUserMedia:', !!navigator.mozGetUserMedia);
        console.log('  MediaRecorder:', !!window.MediaRecorder);
        console.log('  AudioContext:', !!(window.AudioContext || window.webkitAudioContext));
        console.log('  User Agent:', navigator.userAgent);
        
        const getUserMedia = getUserMediaCompat();
        console.log('  Compatible getUserMedia available:', !!getUserMedia);
        
        if (window.MediaRecorder) {
            console.log('  MediaRecorder formats:');
            console.log('    audio/webm;codecs=opus:', MediaRecorder.isTypeSupported('audio/webm;codecs=opus'));
            console.log('    audio/webm:', MediaRecorder.isTypeSupported('audio/webm'));
            console.log('    audio/mp4:', MediaRecorder.isTypeSupported('audio/mp4'));
        }
        
        if (!checkVoiceModeCompatibility()) {
            console.log('');
            console.log('üí° Solutions:');
            if (!navigator.mediaDevices && !navigator.getUserMedia && !navigator.webkitGetUserMedia) {
                console.log('  ‚Ä¢ Update to a modern browser (Chrome 53+, Firefox 36+, Safari 11+)');
                console.log('  ‚Ä¢ Try a different browser');
            }
            if (navigator.mediaDevices && location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
                console.log('  ‚Ä¢ Use HTTPS or access via localhost/127.0.0.1');
            }
        }
    };
    
    // Force refresh background function
    window.refreshBackground = function() {
        console.log('Force refreshing background...');
        const messageList = document.getElementById('message-list');
        messageList.style.cssText = ''; // Clear all inline styles
        applyBackground();
    };
    
    // Simple color test for immediate feedback
    window.testColor = function(color = 'red') {
        const messageList = document.getElementById('message-list');
        console.log('Testing solid color background:', color);
        messageList.style.setProperty('background', color, 'important');
        messageList.style.setProperty('background-image', 'none', 'important');
    };
    
    // Test a simple gradient
    window.testSimpleGradient = function() {
        const messageList = document.getElementById('message-list');
        console.log('Testing simple gradient background');
        messageList.style.setProperty('background', 'linear-gradient(45deg, #ff6b6b, #4ecdc4)', 'important');
        messageList.style.setProperty('background-image', '', 'important');
    };
    
    // Debug function to inspect current styles
    window.debugStyles = function() {
        const messageList = document.getElementById('message-list');
        const computedStyle = window.getComputedStyle(messageList);
        const computedBefore = window.getComputedStyle(messageList, '::before');
        
        console.log('=== MESSAGE LIST ELEMENT ===');
        console.log('background:', messageList.style.background);
        console.log('background-image:', messageList.style.backgroundImage);
        console.log('computed background:', computedStyle.background);
        console.log('computed background-image:', computedStyle.backgroundImage);
        console.log('computed background-color:', computedStyle.backgroundColor);
        
        console.log('=== ::BEFORE PSEUDO ELEMENT ===');
        console.log('computed background:', computedBefore.background);
        console.log('computed opacity:', computedBefore.opacity);
        console.log('z-index:', computedBefore.zIndex);
        
        console.log('=== CSS VARIABLES ===');
        console.log('--bg-overlay-opacity:', getComputedStyle(document.documentElement).getPropertyValue('--bg-overlay-opacity'));
    };
    
    // Remove overlay temporarily for testing
    window.removeOverlay = function() {
        console.log('Temporarily removing background overlay...');
        document.documentElement.style.setProperty('--bg-overlay-opacity', '0');
        
        // Also try to hide it completely
        const style = document.createElement('style');
        style.id = 'temp-no-overlay';
        style.textContent = '.message-list::before { display: none !important; }';
        document.head.appendChild(style);
        
        console.log('Overlay removed. Try changing background now.');
    };
    
    // Restore overlay
    window.restoreOverlay = function() {
        console.log('Restoring background overlay...');
        const tempStyle = document.getElementById('temp-no-overlay');
        if (tempStyle) {
            tempStyle.remove();
        }
        updateBackgroundOpacity();
        console.log('Overlay restored.');
    };
    
    console.log('üé® Background & Voice System Initialized!');
    console.log('');
    console.log('üé® Background Test Commands:');
    console.log('‚Ä¢ testBackground("sunset") - Beautiful sunset gradient');
    console.log('‚Ä¢ testBackground("gradient") - Blue-purple gradient');
    console.log('‚Ä¢ testBackground("anime_beach") - Anime beach scene');
    console.log('‚Ä¢ testBackground("anime_starry") - Starry night sky');
    console.log('‚Ä¢ testBackground("default") - Back to default');
    console.log('');
    console.log('üé§ Voice Mode Test Commands:');
    console.log('‚Ä¢ testVoiceMode() - Toggle Voice Mode on/off');
    console.log('‚Ä¢ checkVoiceMode() - Check Voice Mode compatibility & status');
    console.log('');
    console.log('üîß Debug Commands:');
    console.log('‚Ä¢ debugStyles() - Check CSS details');
    console.log('‚Ä¢ removeOverlay() - Remove overlay layer');
    console.log('');
    if (!isVoiceModeSupported) {
        console.log('‚ö†Ô∏è Voice Mode not supported in current environment');
        console.log('üí° Try: checkVoiceMode() for solutions');
    } else {
        console.log('‚ú® Voice Mode should work! Try clicking the toggle or: testVoiceMode()');
    }



    // Manual recording control
    voiceMic.addEventListener('click', () => {
        if (!voiceMode) return;
        
        // Check if we're in fallback mode (file upload)
        const fileInput = document.getElementById('voice-file-input');
        if (fileInput) {
            console.log('üé§ Opening file selector (fallback mode)');
            fileInput.click();
            return;
        }
        
        // Normal recording mode
        if (!recording) {
            startRecording();
        } else {
            stopRecording();
        }
    });

    // Keyboard shortcut support
    document.addEventListener('keydown', (e) => {
        // Ctrl/Cmd + Shift + V: Toggle voice mode
        if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'V') {
            e.preventDefault();
            voiceToggle.click();
        }
        
        // Space key: Control recording in voice mode (only when not focused on input)
        if (e.code === 'Space' && voiceMode && document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
            e.preventDefault();
            if (!recording) {
                startRecording();
            } else {
                stopRecording();
            }
        }
        
        // Esc key: Stop recording or TTS playback
        if (e.key === 'Escape') {
            if (recording) {
                stopRecording();
            }
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }
            
            // Clear all audio queues
            audioQueue = [];
            isPlayingQueue = false;
            streamingAudioQueue.forEach(url => URL.revokeObjectURL(url));
            streamingAudioQueue = [];
            isPlayingStreamingQueue = false;
            
            ttsStopBtn.textContent = 'Stop Playback';
        }
    });



    uploadBtn.addEventListener('click', () => imageInput.click());
    imageInput.addEventListener('change', e => {
        if (e.target.files.length > 0) handleImageUpload(e.target.files[0]);
    });
    removeAttachmentBtn.addEventListener('click', clearAttachment);

    messageForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        const message = messageInput.value.trim();
        if (!message) return;
        sendButton.disabled = true;
        messageInput.disabled = true;
        messageList.appendChild(createMessage(message, true, false, uploadedImageUrl));
        messageInput.value = '';
        const currentImageUrl = uploadedImageUrl;
        clearAttachment();
        try {
            await handleSmartRequest(message, currentImageUrl);
        } catch (error) {
            console.error('Error:', error);
            messageList.appendChild(createMessage('Sorry, an error occurred.', false));
        } finally {
            sendButton.disabled = false;
            messageInput.disabled = false;
            messageInput.focus();
        }
    });

    // Polyfill for older browsers
    function getUserMediaCompat() {
        console.log('üîç Checking getUserMedia compatibility...');
        
        // Modern API
        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            console.log('‚úÖ Using modern mediaDevices.getUserMedia');
            return navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
        }
        
        // Legacy API fallback
        const getUserMedia = navigator.getUserMedia || 
                           navigator.webkitGetUserMedia || 
                           navigator.mozGetUserMedia || 
                           navigator.msGetUserMedia;
        
        console.log('üîç Legacy API check:');
        console.log('  navigator.getUserMedia:', !!navigator.getUserMedia);
        console.log('  navigator.webkitGetUserMedia:', !!navigator.webkitGetUserMedia);
        console.log('  navigator.mozGetUserMedia:', !!navigator.mozGetUserMedia);
        console.log('  navigator.msGetUserMedia:', !!navigator.msGetUserMedia);
        
        if (!getUserMedia) {
            console.error('‚ùå No getUserMedia API found in this browser');
            console.log('üîç Browser details:');
            console.log('  User Agent:', navigator.userAgent);
            console.log('  Browser name:', getBrowserInfo().name);
            console.log('  Browser version:', getBrowserInfo().version);
            return null;
        }
        
        console.log('‚úÖ Using legacy getUserMedia API');
        
        // Promisify the legacy API
        return function(constraints) {
            return new Promise((resolve, reject) => {
                getUserMedia.call(navigator, constraints, resolve, reject);
            });
        };
    }

    // Browser detection helper
    function getBrowserInfo() {
        const ua = navigator.userAgent;
        let name = 'Unknown';
        let version = 'Unknown';

        if (ua.indexOf('Chrome') > -1) {
            name = 'Chrome';
            const match = ua.match(/Chrome\/(\d+)/);
            version = match ? match[1] : 'Unknown';
        } else if (ua.indexOf('Firefox') > -1) {
            name = 'Firefox';
            const match = ua.match(/Firefox\/(\d+)/);
            version = match ? match[1] : 'Unknown';
        } else if (ua.indexOf('Safari') > -1 && ua.indexOf('Chrome') === -1) {
            name = 'Safari';
            const match = ua.match(/Version\/(\d+)/);
            version = match ? match[1] : 'Unknown';
        } else if (ua.indexOf('Edge') > -1) {
            name = 'Edge';
            const match = ua.match(/Edge\/(\d+)/);
            version = match ? match[1] : 'Unknown';
        } else if (ua.indexOf('MSIE') > -1 || ua.indexOf('Trident') > -1) {
            name = 'Internet Explorer';
            const match = ua.match(/(?:MSIE |rv:)(\d+)/);
            version = match ? match[1] : 'Unknown';
        }

        return { name, version };
    }

    // Fallback voice mode for unsupported browsers
    function enableFallbackVoiceMode() {
        console.log('üé§ Setting up fallback voice mode...');
        
        // Hide volume bars and timer (not applicable for file upload)
        const volumeIndicator = document.querySelector('.volume-indicator');
        const recordingTimer = document.getElementById('recording-timer');
        if (volumeIndicator) volumeIndicator.style.display = 'none';
        if (recordingTimer) recordingTimer.style.display = 'none';
        
        // Update voice text
        voiceText.textContent = 'Click üìÅ to upload audio file (mp3, wav, etc.)';
        
        // Change microphone button to file upload
        voiceMic.textContent = 'üìÅ';
        voiceMic.title = 'Upload audio file';
        
        // Create file input for audio upload
        if (!document.getElementById('voice-file-input')) {
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.id = 'voice-file-input';
            fileInput.accept = 'audio/*';
            fileInput.style.display = 'none';
            voicePanel.appendChild(fileInput);
            
            fileInput.addEventListener('change', handleAudioFileUpload);
        }
        
        // Show TTS controls
        ttsControls.style.display = 'flex';
        
        console.log('‚úÖ Fallback voice mode enabled');
    }

    // Handle audio file upload
    async function handleAudioFileUpload(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        console.log('üé§ Processing uploaded audio file:', file.name);
        voiceText.textContent = `Processing ${file.name}...`;
        
        // Check file size (limit to 25MB)
        if (file.size > 25 * 1024 * 1024) {
            voiceText.textContent = 'Audio file too large (max 25MB)';
            setTimeout(() => {
                voiceText.textContent = 'Click üìÅ to upload audio file (mp3, wav, etc.)';
            }, 3000);
            return;
        }
        
        // Send to speech-to-text API
        const formData = new FormData();
        formData.append('audio', file);
        
        try {
            voiceText.textContent = 'Converting speech to text...';
            
            const res = await fetch('http://127.0.0.1:9200/speech_to_text', {
                method: 'POST',
                body: formData
            });
            
            if (!res.ok) {
                throw new Error(`HTTP error! status: ${res.status}`);
            }
            
            const data = await res.json();
            if (data.code === 0 && data.text) {
                const userText = data.text.trim();
                if (userText) {
                    voiceText.textContent = `Recognition result: "${userText}"`;
                    
                    // Send to chat API
                    console.log('üé§ Sending recognized text to chat API:', userText);
                    await sendMessage(userText);
                    
                    // Reset for next upload
                    setTimeout(() => {
                        voiceText.textContent = 'Click üìÅ to upload audio file (mp3, wav, etc.)';
                        event.target.value = ''; // Clear file input
                    }, 2000);
                } else {
                    voiceText.textContent = 'No speech detected in audio file';
                    setTimeout(() => {
                        voiceText.textContent = 'Click üìÅ to upload audio file (mp3, wav, etc.)';
                    }, 3000);
                }
            } else {
                throw new Error(data.message || 'Speech recognition failed');
            }
        } catch (error) {
            console.error('Error processing audio file:', error);
            voiceText.textContent = 'Failed to process audio file';
            setTimeout(() => {
                voiceText.textContent = 'Click üìÅ to upload audio file (mp3, wav, etc.)';
            }, 3000);
        }
    }

    async function startVoiceMode() {
        try {
            // Get compatible getUserMedia function
            const getUserMedia = getUserMediaCompat();
            
            if (!getUserMedia) {
                // Fallback: Enable voice mode without live microphone
                console.log('üé§ Enabling fallback voice mode (file upload only)');
                enableFallbackVoiceMode();
                return;
            }
            
            // Check HTTPS requirement (except for localhost) - only for modern browsers
            if (navigator.mediaDevices && location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
                console.warn('‚ö†Ô∏è Voice features work better with HTTPS connection');
            }
            
            console.log('üé§ Requesting microphone access...');
            vadStream = await getUserMedia({
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true
                }
            });
            console.log('üé§ Microphone access granted');
            
            // Check MediaRecorder support
            if (!window.MediaRecorder) {
                throw new Error('Browser does not support audio recording');
            }
            
            // Try to create MediaRecorder with preferred format, fallback if needed
            let mediaRecorderOptions = { mimeType: 'audio/webm;codecs=opus' };
            if (!MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
                console.warn('‚ö†Ô∏è Opus codec not supported, trying webm');
                mediaRecorderOptions = { mimeType: 'audio/webm' };
                if (!MediaRecorder.isTypeSupported('audio/webm')) {
                    console.warn('‚ö†Ô∏è WebM not supported, using default format');
                    mediaRecorderOptions = {};
                }
            }
            
            mediaRecorder = new MediaRecorder(vadStream, mediaRecorderOptions);
            console.log('üé§ MediaRecorder created with format:', mediaRecorderOptions.mimeType || 'default');
        mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
        mediaRecorder.onstop = handleRecordedAudio;

        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') {
                await audioCtx.resume();
            }
            
        analyser = audioCtx.createAnalyser();
            analyser.fftSize = 2048;
            analyser.smoothingTimeConstant = 0.3;
        const source = audioCtx.createMediaStreamSource(vadStream);
        source.connect(analyser);

            // Only start volume monitoring, not VAD auto recording
            vadInterval = setInterval(updateVolumeDisplay, 50);
            
        } catch (error) {
            console.error('Error starting voice mode:', error);
            throw error;
        }
    }

    function updateVolumeDisplay() {
        if (!analyser || !voiceMode) return;
        
        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        analyser.getByteFrequencyData(dataArray);
        
        // Calculate volume
        let sum = 0;
            for (let i = 0; i < bufferLength; i++) {
            sum += dataArray[i];
        }
        const volume = sum / bufferLength / 255;
        
        // Update volume bar display
        const activeBarCount = Math.floor(volume * volumeBars.length * 3); // Increase sensitivity
        volumeBars.forEach((bar, index) => {
            if (index < activeBarCount) {
                bar.style.height = `${Math.min(30, 10 + volume * 40)}px`;
                bar.style.backgroundColor = volume > 0.6 ? '#dc3545' : 
                                           volume > 0.3 ? '#ffc107' : '#28a745';
            } else {
                bar.style.height = '3px';
                bar.style.backgroundColor = '#dee2e6';
            }
        });
    }

    function startRecording() {
        if (recording) return;
        
        audioChunks = [];
        mediaRecorder.start();
        recording = true;
        recordingStartTime = Date.now();
        
        voiceText.textContent = 'Recording...';
        voiceMic.classList.add('recording');
        voiceMic.textContent = '‚èπÔ∏è';
        
        // Start recording timer
        recordingTimerInterval = setInterval(updateRecordingTimer, 100);
    }

    function stopRecording() {
        if (!recording) return;
        
        mediaRecorder.stop();
        recording = false;
        
        voiceText.textContent = 'Processing...';
        voiceMic.classList.remove('recording');
        voiceMic.textContent = 'üé§';
        
        // Stop recording timer
        if (recordingTimerInterval) {
            clearInterval(recordingTimerInterval);
            recordingTimerInterval = null;
        }
        resetRecordingTimer();
    }

    function updateRecordingTimer() {
        if (!recording) return;
        
        const elapsed = Date.now() - recordingStartTime;
        const minutes = Math.floor(elapsed / 60000);
        const seconds = Math.floor((elapsed % 60000) / 1000);
        recordingTimer.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

    function resetRecordingTimer() {
        recordingTimer.textContent = '00:00';
    }

    function stopVoiceMode() {
        if (vadInterval) clearInterval(vadInterval);
        if (recordingTimerInterval) {
            clearInterval(recordingTimerInterval);
            recordingTimerInterval = null;
        }
        if (vadStream) {
            vadStream.getTracks().forEach(t => t.stop());
            vadStream = null;
        }
        if (audioCtx) {
            audioCtx.close();
            audioCtx = null;
        }
        if (currentAudio) {
            currentAudio.pause();
            currentAudio = null;
        }
        
        // Reset state
        recording = false;
            silenceFrames = 0;
        
        // Clean up TTS related state
        audioQueue = [];
        isPlayingQueue = false;
        streamingAudioQueue.forEach(url => URL.revokeObjectURL(url));
        streamingAudioQueue = [];
        isPlayingStreamingQueue = false;
        streamingTTSBuffer = '';
        if (streamingTTSTimeout) {
            clearTimeout(streamingTTSTimeout);
            streamingTTSTimeout = null;
        }
        
        voiceCanvas.style.display = 'none';
        ttsControls.style.display = 'none';
        voiceText.textContent = 'Click microphone to start recording';
        voiceMic.classList.remove('recording');
        voiceMic.textContent = 'üé§';
        resetRecordingTimer();
        
        // Reset volume bars
        volumeBars.forEach(bar => {
            bar.style.height = '3px';
            bar.style.backgroundColor = '#dee2e6';
        });
    }



    async function handleRecordedAudio() {
        const blob = new Blob(audioChunks, {type: 'audio/webm'});
        
        // Check recording length
        if (blob.size < 1000) { // Less than 1KB might be invalid recording
            voiceText.textContent = 'Recording too short, please try again';
            setTimeout(() => {
                voiceText.textContent = 'Click microphone to start recording';
            }, 2000);
            return;
        }
        
        const formData = new FormData();
        formData.append('audio', blob, 'record.webm');
        
        let retryCount = 0;
        const maxRetries = 3;
        
        while (retryCount < maxRetries) {
        try {
                voiceText.textContent = `Speech recognition... ${retryCount > 0 ? `(retry ${retryCount}/${maxRetries})` : ''}`;
                
            const res = await fetch('http://127.0.0.1:9200/speech_to_text', {
                method: 'POST',
                    body: formData,
                    timeout: 10000 // 10 second timeout
            });
                
                if (!res.ok) {
                    throw new Error(`HTTP error! status: ${res.status}`);
                }
                
            const data = await res.json();
            if (data.code === 0 && data.text) {
                const userText = data.text.trim();
                if (userText) {
                        voiceText.textContent = `Recognition result: "${userText}"`;
                    messageList.appendChild(createMessage(userText, true));
                    messageList.scrollTop = messageList.scrollHeight;
                    await handleSmartRequest(userText);
                        return; // Success, exit retry loop
                    } else {
                        voiceText.textContent = 'No valid speech detected, please try again';
                }
                } else {
                    throw new Error(data.message || 'Speech recognition failed');
            }
                break;
        } catch (e) {
                console.error('Speech to text failed:', e);
                retryCount++;
                
                if (retryCount >= maxRetries) {
                    voiceText.textContent = 'Speech recognition failed, please check network or retry';
                } else {
                    await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1 second before retry
                }
            }
        }
        
        // Reset status text after 3 seconds
        setTimeout(() => {
            voiceText.textContent = 'Click microphone to start recording';
        }, 3000);
    }

    async function handleSmartRequest(message, imageUrl = null) {
        const responseDiv = createMessage('', false, true);
        messageList.appendChild(responseDiv);
        messageList.scrollTop = messageList.scrollHeight;

        const response = await fetch('http://127.0.0.1:9200/request_smart', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ user_input: message, image_url: imageUrl })
        });

        await processSmartStream(response, responseDiv);
    }

    async function processSmartStream(response, messageDiv) {
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        const contentDiv = messageDiv.querySelector('.message-content');
        const textSpan = contentDiv.querySelector('span');
        const cursor = contentDiv.querySelector('.cursor');
        let responseText = '';
        let buffer = '';

        // Reset streaming TTS buffer
        streamingTTSBuffer = '';
        if (streamingTTSTimeout) {
            clearTimeout(streamingTTSTimeout);
            streamingTTSTimeout = null;
        }

        try {
            while (true) {
                const {done, value} = await reader.read();
                if (done) {
                    if (cursor) cursor.remove();
                    
                    // Handle final playback based on TTS mode
                    if (responseText && voiceMode) {
                        if (ttsMode === 'complete') {
                            playTTS(responseText);
                        } else if (ttsMode === 'streaming' && streamingTTSBuffer.length > 0) {
                            // Play remaining streaming buffer content
                            playTTSChunkStreaming(streamingTTSBuffer);
                            streamingTTSBuffer = '';
                        }
                    }
                    break;
                }

                buffer += decoder.decode(value, {stream: true});
                const lines = buffer.split('\n');
                buffer = lines.pop() || '';

                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        const data = line.slice(5).trim();
                        if (data === '[DONE]') continue;

                        try {
                            const parsed = JSON.parse(data);
                            if (parsed.code === 0 && parsed.chunk) {
                                if (parsed.chunk.startsWith('[IMAGE:') && parsed.chunk.endsWith(']')) {
                                    const url = parsed.chunk.slice(7, -1);
                                    const img = document.createElement('img');
                                    img.src = url;
                                    img.className = 'image-in-message';
                                    contentDiv.appendChild(img);
                                } else {
                                    responseText += parsed.chunk;
                                    textSpan.textContent = responseText;
                                    
                                    // Streaming TTS processing
                                    if (voiceMode && ttsMode === 'streaming') {
                                        handleStreamingTTS(parsed.chunk);
                                    }
                                }
                                messageList.scrollTop = messageList.scrollHeight;
                            }
                        } catch (e) {
                            console.error('Error parsing chunk:', e);
                        }
                    }
                }
            }

        } catch (error) {
            console.error('Stream processing error:', error);
            textSpan.textContent = 'Error processing response.';
            if (cursor) cursor.remove();
        }
    }

    function handleStreamingTTS(chunk) {
        streamingTTSBuffer += chunk;
        
        // Clear previous timeout
        if (streamingTTSTimeout) {
            clearTimeout(streamingTTSTimeout);
        }
        
        // Check for complete sentences (ending with punctuation)
        const sentenceEnders = /[„ÄÇÔºÅÔºü\.!?;Ôºõ]/;
        const sentences = streamingTTSBuffer.split(sentenceEnders);
        
        if (sentences.length > 1) {
            // Has complete sentences, play all content except the last fragment
            const completeText = sentences.slice(0, -1).join('') + '.';
            streamingTTSBuffer = sentences[sentences.length - 1]; // Keep unfinished part
            
            if (completeText.trim().length > 5) { // At least 5 characters to play
                playTTSChunkStreaming(completeText);
            }
        } else {
            // No complete sentence, set timeout (play if no new content in 3 seconds)
            streamingTTSTimeout = setTimeout(() => {
                if (streamingTTSBuffer.trim().length > 10) { // At least 10 characters
                    playTTSChunkStreaming(streamingTTSBuffer);
                    streamingTTSBuffer = '';
                }
            }, 3000);
        }
    }

    let audioQueue = [];
    let isPlayingQueue = false;
    let streamingAudioQueue = [];
    let isPlayingStreamingQueue = false;

    async function playTTS(text) {
        if (!text || !voiceMode) return;
        
        // Stop currently playing audio
        if (currentAudio) {
            currentAudio.pause();
            currentAudio = null;
        }
        
        // Clear queue, only play complete text
        audioQueue = [];
        isPlayingQueue = false;
        
        await playTTSChunk(text);
    }

    // Real streaming TTS implementation
    async function playTTSChunkStreaming(text) {
        if (!text || !voiceMode) return;
        
        console.log(`Starting streaming TTS for: ${text.substring(0, 50)}...`);
        
        try {
            const response = await fetch('http://127.0.0.1:9200/text_to_speech_stream', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    text: text,
                    voice: selectedVoice
                })
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            
            let audioChunks = [];
            
            while (true) {
                const { done, value } = await reader.read();
                
                if (done) {
                    console.log('Streaming TTS completed');
                    break;
                }
                
                const chunk = decoder.decode(value, { stream: true });
                const lines = chunk.split('\n');
                
                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        const data = line.slice(6).trim();
                        if (data === '[DONE]') continue;
                        
                        try {
                            const parsed = JSON.parse(data);
                            if (parsed.code === 0) {
                                if (parsed.type === 'audio_chunk') {
                                    // Play audio chunk immediately
                                    const audioBlob = base64ToBlob(parsed.data, 'audio/mp3');
                                    const audioUrl = URL.createObjectURL(audioBlob);
                                    
                                    // Add to streaming queue
                                    streamingAudioQueue.push(audioUrl);
                                    
                                    // Start playing if not already playing
                                    if (!isPlayingStreamingQueue) {
                                        playNextStreamingAudio();
                                    }
                                } else if (parsed.type === 'audio_end') {
                                    console.log('Streaming TTS audio completed');
                                } else if (parsed.type === 'error') {
                                    console.error('Streaming TTS error:', parsed.message);
                                }
                            }
                        } catch (e) {
                            console.error('Error parsing streaming TTS chunk:', e);
                        }
                    }
                }
            }
            
        } catch (error) {
            console.error('Streaming TTS error:', error);
            // Fallback to regular TTS
            await playTTSChunk(text);
        }
    }

    function base64ToBlob(base64Data, contentType) {
        const byteCharacters = atob(base64Data);
        const byteArrays = [];
        
        for (let offset = 0; offset < byteCharacters.length; offset += 512) {
            const slice = byteCharacters.slice(offset, offset + 512);
            
            const byteNumbers = new Array(slice.length);
            for (let i = 0; i < slice.length; i++) {
                byteNumbers[i] = slice.charCodeAt(i);
            }
            
            const byteArray = new Uint8Array(byteNumbers);
            byteArrays.push(byteArray);
        }
        
        return new Blob(byteArrays, { type: contentType });
    }

    function playNextStreamingAudio() {
        if (streamingAudioQueue.length > 0) {
            isPlayingStreamingQueue = true;
            const audioUrl = streamingAudioQueue.shift();
            
            if (currentAudio) {
                currentAudio.pause();
            }
            
            currentAudio = new Audio(audioUrl);
            ttsStopBtn.textContent = 'Stop Playback';
            
            currentAudio.onended = () => {
                URL.revokeObjectURL(audioUrl); // Clean up
                if (streamingAudioQueue.length > 0) {
                    playNextStreamingAudio();
                } else {
                    isPlayingStreamingQueue = false;
                    currentAudio = null;
                    ttsStopBtn.textContent = 'Stop Playback';
                }
            };
            
            currentAudio.onerror = (e) => {
                console.error('Audio playback error:', e);
                URL.revokeObjectURL(audioUrl);
                if (streamingAudioQueue.length > 0) {
                    playNextStreamingAudio();
                } else {
                    isPlayingStreamingQueue = false;
                }
            };
            
            currentAudio.play().catch(e => {
                console.error('Failed to play streaming audio:', e);
                if (streamingAudioQueue.length > 0) {
                    playNextStreamingAudio();
                } else {
                    isPlayingStreamingQueue = false;
                }
            });
        } else {
            isPlayingStreamingQueue = false;
        }
    }

    async function playTTSChunk(text) {
        if (!text || !voiceMode) return;
        
        // Â¶ÇÊûúÊòØÊµÅÂºèÊ®°ÂºèÔºåÊ∑ªÂä†Âà∞ÈòüÂàó
        if (ttsMode === 'streaming') {
            audioQueue.push(text);
            if (!isPlayingQueue) {
                processAudioQueue();
            }
        } else {
            // ÂÆåÊï¥Ê®°ÂºèÁõ¥Êé•Êí≠Êîæ
            await generateAndPlayAudio(text);
        }
    }

    async function processAudioQueue() {
        if (audioQueue.length === 0) {
            isPlayingQueue = false;
            return;
        }
        
        isPlayingQueue = true;
        const text = audioQueue.shift();
        
        try {
            await generateAndPlayAudio(text);
            // Êí≠ÊîæÂÆåÊàêÂêéÂ§ÑÁêÜÈòüÂàó‰∏≠ÁöÑ‰∏ã‰∏Ä‰∏™
            setTimeout(() => processAudioQueue(), 100);
        } catch (e) {
            console.error('Audio queue processing error:', e);
            // Âá∫ÈîôÊó∂‰πüË¶ÅÁªßÁª≠Â§ÑÁêÜÈòüÂàó
            setTimeout(() => processAudioQueue(), 1000);
        }
    }

    async function generateAndPlayAudio(text) {
        let retryCount = 0;
        const maxRetries = 2;
        
        while (retryCount < maxRetries) {
            try {
                if (ttsMode === 'streaming') {
                                ttsStopBtn.textContent = 'Streaming...';
        } else {
            ttsStopBtn.textContent = 'Generating...';
                }
                
            const resp = await fetch('http://127.0.0.1:9200/text_to_speech', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        text: text,
                        voice: selectedVoice 
                    }),
                    timeout: 15000 // 15 second timeout
                });
                
                if (!resp.ok) {
                    throw new Error(`TTS HTTP error! status: ${resp.status}`);
                }
                
                const blob = await resp.blob();
                if (blob.size < 1000) {
                    throw new Error('TTS response too small');
                }
                
                const url = URL.createObjectURL(blob);
                const audio = new Audio(url);
                
                // Set audio event listeners
                audio.onplay = () => {
                    currentAudio = audio;
                    ttsStopBtn.textContent = 'Stop Playback';
                };
                
                audio.onended = () => {
                    ttsStopBtn.textContent = 'Stop Playback';
                    URL.revokeObjectURL(url);
                    if (currentAudio === audio) {
                        currentAudio = null;
                    }
                };
                
                audio.onerror = () => {
                    console.error('Audio playback error');
                    ttsStopBtn.textContent = 'Playback Failed';
                    URL.revokeObjectURL(url);
                    if (currentAudio === audio) {
                        currentAudio = null;
                    }
                };
                
                // Play audio
                await audio.play();
                
                // Wait for audio playback to complete
                return new Promise((resolve, reject) => {
                    audio.onended = () => {
                        ttsStopBtn.textContent = 'Stop Playback';
                        URL.revokeObjectURL(url);
                        if (currentAudio === audio) {
                            currentAudio = null;
                        }
                        resolve();
                    };
                    
                    audio.onerror = () => {
                        reject(new Error('Audio playback failed'));
                    };
                });
                
        } catch (e) {
                console.error('TTS failed:', e);
                retryCount++;
                
                if (retryCount >= maxRetries) {
                    ttsStopBtn.textContent = 'TTS Failed';
                    setTimeout(() => {
                        ttsStopBtn.textContent = 'Stop Playback';
                    }, 3000);
                    throw e;
                } else {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }
        }
    }

    function handleImageUpload(file) {
        if (!file || !file.type.startsWith('image/')) {
            alert('Please select a valid image file');
            return;
        }
        const maxSize = 10 * 1024 * 1024;
        if (file.size > maxSize) {
            alert('Image file size cannot exceed 10MB, please select a smaller file or compress it');
            return;
        }
        if (file.size > 1024 * 1024) {
            compressImage(file).then(processImageFile).catch(err => {
                console.error('Image compression failed:', err);
                processImageFile(file);
            });
        } else {
            processImageFile(file);
        }
    }

    function processImageFile(file) {
        const reader = new FileReader();
        reader.onload = function(e) {
            uploadedImageUrl = e.target.result;
            previewImage.src = uploadedImageUrl;
            attachmentPreview.classList.add('show');
        };
        reader.readAsDataURL(file);
    }

    function compressImage(file, quality = 0.8, maxWidth = 1920, maxHeight = 1080) {
        return new Promise((resolve, reject) => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = new Image();

            img.onload = function() {
                let { width, height } = img;
                if (width > maxWidth || height > maxHeight) {
                    const ratio = Math.min(maxWidth / width, maxHeight / height);
                    width *= ratio;
                    height *= ratio;
                }
                canvas.width = width;
                canvas.height = height;
                ctx.drawImage(img, 0, 0, width, height);
                canvas.toBlob(resolve, file.type, quality);
            };

            img.onerror = reject;
            img.src = URL.createObjectURL(file);

        });
    }

    function clearAttachment() {
        uploadedImageUrl = null;
        previewImage.src = '';
        attachmentPreview.classList.remove('show');
        imageInput.value = '';
    }

    function createMessage(content, isUser, withCursor = false, imageUrl = null) {
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${isUser ? 'user' : 'assistant'}`;

        const avatar = document.createElement('div');
        avatar.className = 'avatar';
        avatar.textContent = isUser ? 'U' : 'AI';

        const messageContent = document.createElement('div');
        messageContent.className = 'message-content';

        if (imageUrl) {
            const img = document.createElement('img');
            img.src = imageUrl;
            img.className = 'image-in-message';
            messageContent.appendChild(img);
        }

        if (withCursor) {
            const textSpan = document.createElement('span');
            textSpan.textContent = content;
            const cursor = document.createElement('span');
            cursor.className = 'cursor';
            messageContent.appendChild(textSpan);
            messageContent.appendChild(cursor);
        } else if (content) {
            const textDiv = document.createElement('div');
            textDiv.textContent = content;
            messageContent.appendChild(textDiv);
        }

        if (isUser) {
            messageDiv.appendChild(messageContent);
            messageDiv.appendChild(avatar);
        } else {
            messageDiv.appendChild(avatar);
            messageDiv.appendChild(messageContent);
        }
        return messageDiv;
    }
});
    </script>
</body>
</html>
